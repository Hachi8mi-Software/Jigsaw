

### **项目需求规格说明书 (Software Requirements Specification)**

**项目名称：** 跨平台拼图应用 ("拼图乐" - Puzzle Fun)
**版本：** 1.0
**日期：** 2025年8月25日

---

#### **1. 引言 (Introduction)**

**1.1. 项目背景与目标**
随着数字娱乐需求的增长，传统的拼图游戏在数字平台上迎来了新的发展机遇。本项目旨在利用现代化的跨平台技术（Tauri + Vue），开发一款集高质量拼图游戏体验与高度自由化拼图创作工具于一体的应用程序。项目目标是为用户提供一个既能休闲放松，又能激发创造力的互动娱乐平台，并覆盖主流桌面及未来的移动端操作系统。

**1.2. 项目概述**
本产品是一款基于 Tauri 和 Vue 技术栈开发的跨平台应用程序，核心包含两大模块：**拼图游戏**和**拼图编辑器**。游戏模块提供丰富的内置图库和多样的难度挑战；编辑器模块则独创性地允许用户通过直接操纵拼图块之间的“边界”来程序化地生成独一无二的拼图切割方案。

**1.3. 目标用户**
*   **休闲玩家：** 寻求放松和消磨时间的各年龄段拼图爱好者。
*   **核心玩家：** 喜欢挑战高难度、不规则形状拼图的资深玩家。
*   **内容创作者：** 希望将个人摄影作品、绘画、设计稿等转化为互动拼图与他人分享的用户。

---

#### **2. 整体描述 (Overall Description)**

**2.1. 产品愿景**
成为拼图爱好者首选的数字平台，通过提供极致的自定义功能和流畅的游戏体验，重新定义数字拼图的乐趣和创造力。

**2.2. 技术栈 (Technology Stack)**
*   **核心框架:** Tauri (提供跨平台能力和原生API访问)
*   **前端框架:** Vue 3 (采用 Composition API 和 TypeScript)
*   **状态管理:** Pinia
*   **UI 库:** Element Plus / Naive UI 或自定义UI组件库
*   **样式方案:** Tailwind CSS / SCSS
*   **核心渲染技术:** SVG (用于拼图块的矢量切割和渲染)
*   **后端语言 (Tauri Core):** Rust

**面向对象+敏捷开发模式**
---

#### **3. 功能需求 (Functional Requirements)**

**3.1. 核心模块一：拼图游戏 (Jigsaw Puzzle Game)**

*   **3.1.1. 素材库 (Asset Library)**
    *   **FR-1.1 内置素材:**
        *   提供一个在线更新的、高质量且版权合规的图片库。
        *   素材需分类，至少包含：自然风光、城市建筑、艺术画作、卡通动漫、可爱动物等。
        *   支持按分类、标签和关键词进行搜索与筛选。
    *   **FR-1.2 用户导入:**
        *   支持用户从本地设备导入图片，格式支持 JPG, PNG, BMP。
        *   导入时提供图片预览和按比例裁剪功能。

*   **3.1.2. 游戏玩法 (Gameplay)**
    *   **FR-2.1 难度设置:**
        *   **数量:** 提供从 9 块 (3x3) 到 1000+ 块 (32x32) 的多级别预设难度。
        *   **形状:** 支持经典的带凹凸连接块的形状和由编辑器创建的不规则形状。
        *   **旋转:** 可在游戏开始前选择是否开启“拼图块旋转”模式，增加挑战。
    *   **FR-2.2 游戏辅助功能:**
        *   **进度管理:** 游戏进度（拼图块位置、时间、步数）自动保存。支持用户随时退出并在下次启动时从断点继续。
        *   **操作:** 提供撤销/重做 (Undo/Redo) 功能。
        *   **视觉辅助:**
            *   **预览原图:** 提供可调节透明度的参考图，并可选择将其置于拼图背景。
            *   **筛选边缘块:** 提供一键高亮或分离所有边缘拼图块的功能。
            *   **自动吸附:** 当两个正确的拼图块被拖拽到足够近的位置时，将自动对齐并合并，伴有音效或视觉提示。

*   **3.1.3. 激励与社交 (Incentives & Social)**
    *   **FR-3.1 数据统计:**
        *   **计时器:** 精确记录完成拼图所用的时间。
        *   **步数统计:** 记录玩家移动拼图块的总次数。
    *   **FR-3.2 排行榜:**
        *   为每个内置拼图设立基于“完成时间”和“移动步数”的排行榜。
        *   排行榜需区分不同的难度级别。
    *   **FR-3.3 成就系统:**
        *   设计一系列成就目标（如“完成首个1000块拼图”、“快如闪电：10分钟内完成100块拼图”等），解锁后授予用户徽章。

**3.2. 核心模块二：程序化拼图编辑器 (Procedural Puzzle Editor)**

*   **3.2.1. 核心设计理念**
    编辑器不使用固定的模板，而是允许用户通过修改基础网格中每条“边界”的凹凸状态，来程序化、创造性地定义最终拼图的切割形状。

*   **3.2.2. 编辑流程**
    *   **FR-4.1 图片上传与网格定义:**
        *   用户上传本地图片。
        *   用户通过输入行列数（例如 10x15）定义基础切割网格。
        *   界面在图片上实时叠加一层半透明的直线网格作为预览。
    *   **FR-4.2 边界编辑模式:**
        *   **交互:** 用户可通过鼠标与**每一条内部网格线**进行交互。
        *   **状态切换:** 点击一条网格线，其状态会在**平直 (Flat)**、**外凸 (Convex)**、**内凹 (Concave)** 三者间循环切换。
        *   **核心约束逻辑:** 系统必须强制执行匹配规则。当一条边界（例如块 A 的右边界）被设为“外凸”，其相邻块（块 B 的左边界）必须自动变为“内凹”，反之亦然。这确保了所有拼图块最终都能完美拼接。
        *   **实时预览:** 边界形状的改变需实时反映在 SVG 网格预览上。
    *   **FR-4.3 全局操作:**
        *   提供**“一键随机化”**按钮，自动为所有内部边界随机分配凹凸状态（并遵守约束逻辑）。
        *   提供**“全部重置”**按钮，将所有边界恢复为平直状态。
    *   **FR-4.4 保存与分享:**
        *   用户可将最终设计（图片引用 + 边界状态数据）保存为一个自定义的 `.puzzle` 文件。
        *   该文件可以分享给其他应用用户，他们可以直接导入进行游戏。

---

#### **4. 跨平台需求 (Cross-Platform Requirements)**

*   **4.1. 桌面端 (Desktop)**
    *   **CR-1.1 操作系统:** 首要目标平台，需支持 Windows, macOS, 和 Linux。
    *   **CR-1.2 UI/UX:** 界面设计需适应不同桌面分辨率，确保良好的视觉和操作体验。

*   **4.2. 移动端 (Mobile - 远期规划)**
    *   **CR-2.1 操作系统:** 探索对鸿蒙、安卓和 iOS 的支持。
    *   **CR-2.2 UI/UX 适配:**
        *   界面需完全响应式，适应手机和平板电脑屏幕。
        *   所有交互（如拖拽、缩放）需为触摸操作进行优化。
        *   设计“碎片栏”或“碎片盘”以有效管理小屏幕上的拼图块。

---

#### **5. 非功能性需求 (Non-Functional Requirements)**

*   **5.1. 性能 (Performance):**
    *   **NFR-1.1 启动速度:** 应用冷启动时间应在3秒以内。
    *   **NFR-1.2 流畅度:** 在进行1000块拼图游戏时，拖拽、合并等核心操作的帧率应保持稳定，无明显卡顿。
*   **5.2. 用户体验 (UX):**
    *   **NFR-2.1 直观性:** 界面布局清晰，功能易于理解，提供简洁的新手引导。
    *   **NFR-2.2 反馈:** 所有用户操作都应有即时的视觉或听觉反馈。
*   **5.3. 稳定性 (Stability):**
    *   **NFR-3.1 可靠性:** 应用运行稳定，无频繁崩溃。
    *   **NFR-3.2 错误处理:** 能优雅地处理异常情况，如导入损坏的图片文件、网络连接中断等。
*   **5.4. 安全性 (Security):**
    *   **NFR-4.1 用户隐私:** 严格保护用户本地文件的隐私，未经许可不得上传任何用户数据。
    *   **NFR-4.2 文件访问:** 使用 Tauri 的安全API进行文件系统交互。
*   **5.5. 可扩展性 (Scalability):**
    *   **NFR-5.1 模块化架构:** 代码结构应清晰，便于未来增加新功能（如在线对战、创意工坊等）。

---

#### **6. 附录 (Appendix)**

**6.1. 给 Cursor AI 的初始项目搭建指令 (Prompt for Cursor)**

```
I am building a cross-platform Jigsaw Puzzle application using Tauri and Vue 3. Please set up the initial project structure and generate the code for the main components based on the following detailed specification.

**Core Technologies:**
*   Framework: Tauri
*   Frontend: Vue 3 with TypeScript and Composition API
*   State Management: Pinia
*   Styling: Tailwind CSS
*   Rendering Engine for Puzzle Pieces: SVG

**Initial Project Structure:**
/src
├── assets/
├── components/
│   ├── PuzzleBoard.vue       # The main game board
│   └── SvgBoundary.vue       # A component to render a single interactive boundary in the editor
├── views/
│   ├── GameView.vue          # Hosts the PuzzleBoard and game UI
│   ├── LibraryView.vue       # Displays built-in puzzles
│   └── EditorView.vue        # The advanced, boundary-based puzzle editor
├── router/
│   └── index.ts
├── stores/
│   ├── game.ts               # Pinia store for active game state
│   └── editor.ts             # Pinia store for puzzle editor state
├── utils/
│   └── svgUtils.ts           # Helper functions for generating SVG path data
├── App.vue
└── main.ts

**Task 1: Generate the Boundary-Based Puzzle Editor (`EditorView.vue`)**
This is the most complex part. Please implement the following:
1.  **Layout:** A section for image upload and grid size input (rows, cols). A main area to display the image with an interactive SVG overlay. Buttons for "Randomize Boundaries" and "Reset".
2.  **SVG Overlay:** Generate an SVG grid on top of the image based on user input.
3.  **Interactivity:** Each internal line of the grid should be an interactive component (`SvgBoundary.vue`).
    *   On hover, it should highlight.
    *   On click, it should cycle its state ('flat', 'convex', 'concave') in the `editor.ts` Pinia store.
4.  **Constraint Logic:** When a boundary's state is changed, it must update the state of the corresponding boundary on the adjacent piece to ensure they fit (convex <-> concave). This logic should be managed within the Pinia store's actions.
5.  **Path Generation:** In `svgUtils.ts`, create a function `generatePathData(type, start, end)` that returns an SVG path string for 'flat' (line), 'convex' (curve out), and 'concave' (curve in) types. The `EditorView` should use this to render the preview.

**Task 2: Generate the Game View (`GameView.vue` and `PuzzleBoard.vue`)**
1.  The `GameView` should be able to receive puzzle data (image and piece definitions) from the Library or Editor.
2.  The `PuzzleBoard.vue` component should:
    *   Take the puzzle data as a prop.
    *   For each piece, generate an SVG `<path>` element with the correct shape and a `<pattern>` fill using the source image.
    *   Implement drag-and-drop functionality for these SVG pieces.
    *   Add placeholders for a timer and move counter.

**Task 3: Setup Basic Routing and State Management**
*   Configure Vue Router with routes for `/`, `/game`, and `/editor`.
*   Setup the Pinia stores `game.ts` and `editor.ts` with basic state properties (e.g., `gridSize`, `boundaries`, `piecePositions`).

Please generate the code for these files, ensuring to use TypeScript, the Vue 3 Composition API, and provide comments for Tauri-specific integrations like file dialogs.
```